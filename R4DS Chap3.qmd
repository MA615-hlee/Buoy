---
title: "Class 11 - Sep 26"
format: 
   html:
      embed-resources: true
editor: visual
---

## Assignments due on Monday

1.  please submit github URL for the buoy reading assignment

2.  Exercises from R4DS\
    a - 3.2.5: 1,4,5\
    b - 3.3.5: 1,4\
    c - 3.5.7: 1,2,4,6

## Cheat Sheets

[dplyr](https://dplyr.tidyverse.org/)

[tidyr](https://tidyr.tidyverse.org/)

[stringr](https://stringr.tidyverse.org/)

### using a cheatsheet

Examples from dplyr

## R4DS Chapter 3

```{r}
#| label: R4DS_ch_3-1
#| warning: true
#| message: true

library(nycflights13)
library(tidyverse)

flights_here <- flights

```

### Rows - Manipulate Cases

filter() arrange() distinct()

```{r}
#| label: rows
#| warning: false
#| message: false

flights |> filter(dep_delay > 120)

delay_120 <- flights_here |> filter(dep_delay > 120)

library(magrittr) 

flights_here %<>% filter(dep_delay > 120)

delay_order <- flights_here |> arrange(dep_delay)


```

### Columns -- Manipulate Variables

select() mutate()

```{r}
#| label: columns

 flights |> select(year, month, day)
 
 m1 <- flights |> 
     mutate(
      gain = dep_delay - arr_delay,
      speed = distance / air_time * 60
      )

```

### Summarize and groups

```{r}
#| label: groups

flights |> 
   group_by(month)

flights |> 
   group_by(month) |>
   summarise(
    avg_delay = mean(dep_delay, na.rm = TRUE)
   )

```

# A

## 1. In a single pipeline for each condition, find all flights that meet the condition:

```         
-   Had an arrival delay of two or more hours
-   Flew to Houston (IAH or HOU)
-   Were operated by United, American, or Delta
-   Departed in summer (July, August, and September)
-   Arrived more than two hours late, but didn’t leave late
-   Were delayed by at least an hour, but made up over 30 minutes in flight
-   Departed between midnight and 6am (inclusive)
```

```{r}
flights |> filter(arr_delay >= 120)
flights |> filter(dest %in% c("IAH", "HOU"))
flights |> filter(carrier %in% c("UA", "AA", "DL"))
flights |> filter(month %in% c(7, 8, 9))
flights |> filter(arr_delay > 120 & dep_delay <= 0)
flights |> filter(dep_delay >= 60 & (dep_delay - arr_delay) > 30)
flights |> filter(dep_time >= 0 & dep_time <= 600)
```

## 4.Was there a flight on every day of 2013?

```{r}
flights |> 
  distinct(year, month, day) |>
  nrow()

# Yes

```

## 5.Which flights traveled the farthest distance? Which traveled the least distance?

```{r}
flights |> 
  filter(distance == max(distance, na.rm = TRUE) | distance == min(distance, na.rm = TRUE))

print(max(flights$distance, na.rm = TRUE))
print(min(flights$distance, na.rm = TRUE))
```

# B

## 1.Compare dep_time, sched_dep_time, and dep_delay. How would you expect those three numbers to be related?

```{r}
flights |> 
  select(dep_time, sched_dep_time, dep_delay) |>
  filter(!is.na(dep_time), !is.na(sched_dep_time), !is.na(dep_delay)) |>
  slice(1:10)
```

-   dep_time is the actual departure time in hhmm format
-   sched_dep_time is the scheduled departure time in hhmm format
-   dep_delay is the difference between dep_time and sched_dep_time in minutes

## 4. What does the any_of() function do? Why might it be helpful in conjunction with this vector?

```{r}
variables <- c("year", "month", "day", "dep_delay", "arr_delay")

flights |> select(any_of(variables))
```

-   any_of() selects columns that are present in the data frame from a character vector of column names. It is helpful because it avoids errors if some of the specified columns do not exist in the data frame.

# C

## 1.Which carrier has the worst average delays? Challenge: can you disentangle the effects of bad airports vs. bad carriers? Why/why not? (Hint: think about flights \|\> group_by(carrier, dest) \|\> summarize(n()))

```{r}
flights |> 
  group_by(carrier) |>
  summarise(avg_delay = mean(arr_delay, na.rm = TRUE)) |>
  arrange(desc(avg_delay)) |>
  slice(1)

```

## 2.Find the flights that are most delayed upon departure from each destination.

```{r}
flights |> 
  group_by(dest) |>
  filter(dep_delay == max(dep_delay, na.rm = TRUE)) |>
  select(dest, tailnum, dep_delay) |>
  arrange(dest)

print(max(flights$dep_delay, na.rm = TRUE))
```

## 4.What happens if you supply a negative n to slice_min() and friends?

```{r}
flights |> 
  slice_min(dep_delay, n = -5)

```

## 6. Suppose we have the following tiny data frame:

```{r}
df <- tibble(
  x = 1:5,
  y = c("a", "b", "a", "a", "b"),
  z = c("K", "K", "L", "L", "K")
)
```

-   

    a.  Write down what you think the output will look like, then check if you were correct, and describe what group_by() does.

```{r}
df |>
  group_by(y)
```

-   group_by(y) groups the data frame by the values in column y. The output will show the original data frame with an additional grouping structure indicating that the rows are grouped by the unique values in y (a and b).

-   

    b.  Write down what you think the output will look like, then check if you were correct, and describe what arrange() does. Also, comment on how it’s different from the group_by() in part (a).

```{r}
df |>
  arrange(y)
```

-   arrange(y) sorts the data frame in ascending order based on the values in column y. The output will show the rows ordered such that all rows with "a" in column y come before those with "b". Unlike group_by(), which creates a grouping structure without changing the order of rows, arrange() changes the order of the rows in the data frame.

-   

    c.  Write down what you think the output will look like, then check if you were correct, and describe what the pipeline does.

```{r}
df |>
  group_by(y) |>
  summarize(mean_x = mean(x))
```

-   The pipeline groups the data frame by column y and then calculates the mean of column x for each group. The output will be a new data frame with two columns: y and mean_x, where mean_x contains the average of x for each unique value in y.

-   d.Write down what you think the output will look like, then check if you were correct, and describe what the pipeline does. Then, comment on what the message says.

```{r}
cdf |>
  group_by(y, z) |>
  summarize(mean_x = mean(x))
```

-   The pipeline groups the data frame by both columns y and z, and then calculates the mean of column x for each combination of y and z. The output will be a new data frame with three columns: y, z, and mean_x, where mean_x contains the average of x for each unique combination of y and z. The message indicates that the grouping structure has been created based on the specified columns.

-   

    e.  Write down what you think the output will look like, then check if you were correct, and describe what the pipeline does. How is the output different from the one in part (d)?

```{r}
df |>
  group_by(y, z) |>
  summarize(mean_x = mean(x), .groups = "drop")
```

-   The pipeline is similar to part (d), but the addition of .groups = "drop" in the summarize() function means that the resulting data frame will not retain the grouping structure. The output will still have three columns: y, z, and mean_x, but it will be a regular data frame without any grouping attributes. This is different from part (d), where the output would still be grouped by y and z.

-   

    f.  Write down what you think the outputs will look like, then check if you were correct, and describe what each pipeline does. How are the outputs of the two pipelines different?

```{r}
df |>
  group_by(y, z) |>
  summarize(mean_x = mean(x))

df |>
  group_by(y, z) |>
  mutate(mean_x = mean(x))
```

-   The first pipeline groups the data frame by y and z, then calculates the mean of x for each group, resulting in a summary data frame with one row per group. The output will have three columns: y, z, and mean_x.
